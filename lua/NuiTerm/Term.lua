--> NuiTerm/Term.lua
--
local Setup = require("NuiTerm.setup")
local Debug = require("NuiTerm.Debug")

local function log(msg, src)
  local source = "TermWindow"
  if src then
    source = source .. ":" .. src
  end
  Debug.push_message(source, msg)
end

---@class TermWindow
---@field bufnr       number|nil
---@field winid       number|nil
---@field termid      number|nil
---@field name        string
---@field autocmdid   number|nil
---@field config      table
---@field onHide      function|nil
---@field showing     boolean
---@field spawned     boolean
---@field initialized boolean
local TermWindow = {
  ---@typw bufnr = number
  bufnr     = nil,
  winid     = nil,
  termid    = nil,
  name      = "Terminal",
  autocmdid = nil,
  config    = {},
  onHide    = nil,
  showing   = false,
  spawned   = false,
  initialized = false,
}

function TermWindow:IsBufValid()
  local valid = self.bufnr and vim.api.nvim_buf_is_valid(self.bufnr)
  if not valid then
    log("Bufnr was somehow deleted!", "IsBufValid")
  end
  return valid
end

-- Function to Create a new Termianl Instance
-- @param termid number: The Terminal's ID
-- @param width number: The width of the terminal window
-- @param height number: The height of the terminal window
-- @param col number: The X coordinate for the floating window
-- @param row number: The Y coordinate for the floating window
function TermWindow:Init(termid, config, onLeave)
  local obj = setmetatable({}, { __index = self})
  obj.termid = termid
  obj.config = config
  local bufnr = vim.api.nvim_create_buf(false, true)
  vim.bo[bufnr].bufhidden = "hide"
  obj.bufnr = bufnr
  obj.initialized = true
  obj.spawned = false
  return obj
end

function TermWindow:RecreateBuf()
  if not self:IsBufValid() then
    local bufnr = vim.api.nvim_create_buf(false, true)
    vim.bo[bufnr].bufhidden = 'wipe'
    self.bufnr = bufnr
    self.spawned = false
  end
end

function TermWindow:SpawnShell(onLeave)
  -- print("TermWIndow:SpawnShell " .. self.termid)
  -- print("BUFNR: " .. self.bufnr)
  if self.spawned then
    log("Already spawned ID: " .. self.termid, "SpawnShell")
    return
  end
  -- vim.cmd("terminal")
  vim.fn.termopen(vim.o.shell, {
    bufnr = self.bufnr,
    on_exit = function()
      log("ON_EXIT!", "SpawnShell")
      onLeave()
    end,
  })
  self.spawned = true
end

-- Creats a new Floating window, with the specified window confiurations originally passed
-- to this TermWindow instance wihtin Init
-- returns the window ID generated by nvim_open_win
function TermWindow:Show(onLeave)
  self:RecreateBuf()
  if not self.config then
    error("TermWindow:Show(): Self.config is nil", 2)
  end
  log("TermWindow: Bufnr - " .. self.bufnr, "Show")
  local winid = vim.api.nvim_open_win(self.bufnr, true, self.config)
  self.winid  = winid
  self.onHide = onLeave

  self:SpawnShell(onLeave)

  -- When the user moves the focus from the NuiTerm Window to another neovim window,
  -- we call this autocmd. Which in turn calls our 'onLeave' callback, i.e., MainWindow:Hide()
  self.autocmdid = vim.api.nvim_create_autocmd({"WinLeave"}, {
    buffer = self.bufnr,
    callback = function()
      if self.showing and winid and vim.api.nvim_win_is_valid(winid) then
        onLeave()
      end
    end
  })
  -- Mode Keymaps
  --- If in 'terminal' mode, Hitting <Esc> will call MainWindow:NormMode -- Putting you into Normal Mode 
  vim.api.nvim_buf_set_keymap(
    self.bufnr,
    't',
    '<Esc>',
    [[<cmd>lua require('NuiTerm').MainWindow:NormMode()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )
  -- If in 'Normal' mode, Hitting 'i' will call MainWindow:TermMode -- Putting you into TerminalMode
  vim.api.nvim_buf_set_keymap(
    self.bufnr,
    'n',
    'i',
    [[<cmd>lua require('NuiTerm').MainWindow:TermMode()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )
  -- If in 'Normal' mode, Hitting <Esc> will call MainWindow:Hide() -- Hiding the NuiTerm Window
  vim.api.nvim_buf_set_keymap(
    self.bufnr,
    'n',
    '<Esc>',
    [[<cmd>lua require('NuiTerm').MainWindow:Hide()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )
  self.showing = true;
  return winid
end

function TermWindow:Hide()
  if not self.winid or not vim.api.nvim_win_is_valid(self.winid) then
    log("winid is nil, no Termianl to hide", "Hide")
    return
  end

  vim.api.nvim_del_autocmd(self.autocmdid)
  vim.api.nvim_buf_del_keymap(self.bufnr, 't', '<Esc>')
  vim.api.nvim_buf_del_keymap(self.bufnr, 'n', 'i')
  vim.api.nvim_buf_del_keymap(self.bufnr, 'n', '<Esc>')

  self.showing = false;
  vim.api.nvim_win_hide(self.winid)
  self.winid = nil
end

return {
  TermWindow = TermWindow,
}
