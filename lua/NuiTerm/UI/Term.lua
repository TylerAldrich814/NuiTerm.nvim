--> NuiTerm/Term.lua
--
local Setup = require("NuiTerm.setup")
local Utils = require("NuiTerm.utils")
local Debug = require("NuiTerm.Debug")
local fn, api, map = vim.fn, vim.api, vim.keymap.set

local AUGROUP = api.nvim_create_augroup("NuiTermHover", { clear = true })

local log = Debug.LOG_FN("TermWindow", {
  deactivate = true,
})

---@class TermWindow
---@field bufnr       number|nil
---@field winid       number|nil
---@field termid      number|nil
---@field name        string
---@field autocmdid   number|nil
---@field config      table
---@field onHide      function|nil
---@field showing     boolean
---@field spawned     boolean
---@field initialized boolean
local TermWindow = {
  ---@typw bufnr = number
  bufnr       = nil,
  winid       = nil,
  termid      = nil,
  name        = "Terminal",
  autocmdid   = nil,
  config      = {},
  onHide      = nil,
  showing     = false,
  spawned     = false,
  initialized = false,
  originalMouse = "",
}

function TermWindow:IsBufValid()
  local valid = self.bufnr and api.nvim_buf_is_valid(self.bufnr)
  if not valid then
    log("Bufnr was somehow deleted!", "IsBufValid")
  end
  return valid
end

-- Function to Create a new Termianl Instance
-- @param termid number: The Terminal's ID
-- @param width number: The width of the terminal window
-- @param height number: The height of the terminal window
-- @param col number: The X coordinate for the floating window
-- @param row number: The Y coordinate for the floating window
function TermWindow:Init(termid, config)
  local obj = setmetatable({}, { __index = self })
  obj.termid = termid
  obj.config = config
  local bufnr = vim.api.nvim_create_buf(false, true)
  vim.bo[bufnr].bufhidden  = "hide"
  vim.bo[bufnr].buftype    = "acwrite"
  vim.bo[bufnr].modifiable = false
  obj.originalMouse = vim.o.mouse
  obj.bufnr = bufnr
  obj.initialized = true
  obj.spawned = false
  Utils.PreventFileOpenInTerm(obj.bufnr)
  return obj
end

function TermWindow:OnHoverOver(current)
  if current.screenrow >= self.config.row
    and current.screenrow <= self.config.row + self.config.height
  then
    api.nvim_exec_autocmds("User", { pattern = "NuiTermHoverOver" })
    log("Hover Pos: x: " .. current.screencol .. " y: " .. current.screenrow)
  else
    api.nvim_exec_autocmds("User", { pattern = "NuiTermHoverOut" })
    log("NotHovering Over NuiTerm")
  end
end

function TermWindow:RecreateBuf()
  if not self:IsBufValid() then
    local bufnr = api.nvim_create_buf(false, true)
    vim.bo[bufnr].bufhidden = 'wipe'
    self.bufnr = bufnr
    self.spawned = false
  end
end

function TermWindow:SpawnShell(onLeave)
  -- print("TermWIndow:SpawnShell " .. self.termid)
  -- print("BUFNR: " .. self.bufnr)
  if self.spawned then
    log("Already spawned ID: " .. self.termid, "SpawnShell")
    return
  end
  -- vim.cmd("terminal")
  vim.fn.termopen(vim.o.shell, {
    bufnr = self.bufnr,
    on_exit = function()
      log("ON_EXIT!", "SpawnShell")
      onLeave()
    end,
  })
  self.spawned = true
end

-- Creats a new Floating window, with the specified window confiurations originally passed
-- to this TermWindow instance wihtin Init
-- returns the window ID generated by nvim_open_win
function TermWindow:Show(onLeave)
  self:RecreateBuf()
  if not self.config then
    error("TermWindow:Show(): Self.config is nil", 2)
  end
  local winid = api.nvim_open_win(self.bufnr, true, self.config)
  self.winid  = winid
  self.onHide = onLeave

  self:SpawnShell(onLeave)

  -- When the user moves the focus from the NuiTerm Window to another neovim window,
  -- we call this autocmd. Which in turn calls our 'onLeave' callback, i.e., MainWindow:Hide()
  --TODO: We need to somehow detect if the focus left both the Term window AND the tabs window(s)
  --      This might require returning a paramter to 'onLeave' Telling MainWindow:Hide() which function
  --      called it( since we have a handful of functions that call Hide) That way if we tell onLeave that
  --      this AutoCMD is calling it, we can then detect if our focus is on the tabbar or not.
  -- self.autocmdid = api.nvim_create_autocmd({ "WinLeave" }, {
  --   buffer = self.bufnr,
  --   callback = function()
  --     if self.showing and winid and api.nvim_win_is_valid(winid) then
  --       onLeave()
  --     end
  --   end
  -- })

  -- Mode Keymaps
  --- If in 'terminal' mode, Hitting <Esc> will call MainWindow:NormMode -- Putting you into Normal Mode
  api.nvim_buf_set_keymap(
    self.bufnr,
    't',
    '<Esc>',
    [[<cmd>lua require('NuiTerm').MainWindow:NormMode()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )

  api.nvim_buf_set_keymap(
    self.bufnr,
    "i",
    "<LeftDrag>",
    "<nop>",
    { noremap = true, silent = true }
  )
  api.nvim_buf_set_keymap(
    self.bufnr,
    "i",
    "<LeftRelease>",
    "<nop>",
    { noremap = true, silent = true }
  )

  local insert_commands = { "i", "<S-i>", "a", "<S-a>" }
  -- If in 'Normal' mode, Hitting 'i' will call MainWindow:TermMode -- Putting you into TerminalMode
  for _, cmd in ipairs(insert_commands) do
    api.nvim_buf_set_keymap(
      self.bufnr,
      'n',
      cmd,
      [[<cmd>lua require('NuiTerm').MainWindow:TermMode()<CR>]],
      {
        noremap = true,
        silent  = true,
      }
    )
  end
  -- If in 'Normal' mode, Hitting <Esc> will call MainWindow:Hide() -- Hiding the NuiTerm Window
  api.nvim_buf_set_keymap(
    self.bufnr,
    'n',
    "<Esc>",
    [[<cmd>lua require('NuiTerm').MainWindow:Hide()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )
  api.nvim_buf_set_keymap(
    self.bufnr,
    'n',
    require('NuiTerm').keyMaps.next_term,
    [[<cmd>lua require('NuiTerm').MainWindow:NextTerm()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )
  api.nvim_buf_set_keymap(
    self.bufnr,
    'n',
    require('NuiTerm').keyMaps.prev_term,
    [[<cmd>lua require('NuiTerm').MainWindow:PrevTerm()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )
  api.nvim_buf_set_keymap(
    self.bufnr,
    'n',
    require('NuiTerm').keyMaps.close_term,
    [[<cmd>lua require('NuiTerm').MainWindow:DeleteTerm()<CR>]],
    {
      noremap = true,
      silent  = true,
    }
  )

  local resizeCmd = { 'n', 'i' }
  for _, cmd in pairs(resizeCmd) do
    api.nvim_buf_set_keymap(
      self.bufnr,
      cmd,
      require("NuiTerm").keyMaps.term_resize.expand.cmd,
      [[<cmd>lua require('NuiTerm').Expand()<CR>]],
      {
        noremap = true,
        silent  = true,
      }
    )
    api.nvim_buf_set_keymap(
      self.bufnr,
      cmd,
      require("NuiTerm").keyMaps.term_resize.shrink.cmd,
      [[<cmd>lua require('NuiTerm').Shrink()<CR>]],
      {
        noremap = true,
        silent  = true,
      }
    )
  end
  self.showing = true;
  return winid
end

function TermWindow:Hide()
  if not self.winid or not api.nvim_win_is_valid(self.winid) then
    return
  end

  -- api.nvim_del_autocmd(self.autocmdid)
  api.nvim_buf_del_keymap(self.bufnr, 't', '<Esc>')
  api.nvim_buf_del_keymap(self.bufnr, 'n', 'i')
  api.nvim_buf_del_keymap(self.bufnr, 'n', '<Esc>')

  self.showing = false;
  api.nvim_win_hide(self.winid)
  self.winid = nil
end

function TermWindow:Delete()
  self:Hide()
  self.bufnr = nil
  self.termid = nil
end

---@param config table
function TermWindow:UpdateConfig(config)
  self.config = config
end



return {
  TermWindow = TermWindow,
}
