--> NuiTerm/Term.lua
--
local Utils   = require("NuiTerm.utils")
local Debug   = require("NuiTerm.Debug")
local Keymaps = require("NuiTerm.Keymap.Term")
local api     = vim.api

local AUGROUP = api.nvim_create_augroup("NuiTermHover", { clear = true })

local log = Debug.LOG_FN("TermWindow", {
  deactivate = true,
})

---@class TermWindow
---@field bufnr       number|nil
---@field winid       number|nil
---@field termid      number|nil
---@field name        string
---@field autocmdid   number|nil
---@field config      table
---@field onHide      function|nil
---@field showing     boolean
---@field spawned     boolean
---@field initialized boolean
local TermWindow = {
  bufnr       = nil,
  winid       = nil,
  termid      = nil,
  name        = "NuiTerm",
  autocmdid   = nil,
  config      = {},
  onHide      = nil,
  showing     = false,
  spawned     = false,
  initialized = false,
  originalMouse = "",
}

function TermWindow:IsBufValid()
  local valid = self.bufnr and api.nvim_buf_is_valid(self.bufnr)
  if not valid then
    log("Bufnr was somehow deleted!", "IsBufValid")
  end
  return valid
end

-- Function to Create a new Termianl Instance
---@param termid number
---@param config table
function TermWindow:Init(termid, config)
  local obj = setmetatable({}, { __index = self })
  obj.termid = termid
  obj.config = config
  local bufnr = vim.api.nvim_create_buf(false, true)

  vim.bo[bufnr].bufhidden  = "hide"
  vim.bo[bufnr].buftype    = "acwrite"
  vim.bo[bufnr].modifiable = false


  obj.originalMouse = vim.o.mouse
  obj.bufnr = bufnr
  obj.initialized = true
  obj.spawned = false
  Utils.PreventFileOpenInTerm(obj.bufnr)
  return obj
end

---@param current number
function TermWindow:OnHoverOver(current)
  if current.screenrow >= self.config.row
    and current.screenrow <= self.config.row + self.config.height
  then
    api.nvim_exec_autocmds("User", { pattern = "NuiTermHoverOver" })
    log("Hover Pos: x: " .. current.screencol .. " y: " .. current.screenrow)
  else
    api.nvim_exec_autocmds("User", { pattern = "NuiTermHoverOut" })
    log("NotHovering Over NuiTerm")
  end
end

function TermWindow:RecreateBuf()
  if not self:IsBufValid() then
    local bufnr = api.nvim_create_buf(false, true)
    vim.bo[bufnr].bufhidden = 'wipe'
    self.bufnr = bufnr
    self.spawned = false
  end
end

---@param onLeave function
function TermWindow:SpawnShell(onLeave)
  if self.spawned then
    log("Already spawned ID: " .. self.termid, "SpawnShell")
    return
  end
  vim.fn.termopen(vim.o.shell, {
    bufnr = self.bufnr,
    on_exit = function()
      log("ON_EXIT!", "SpawnShell")
      onLeave()
    end,
  })
  self.spawned = true
end

-- Creats a new Floating window, with the specified window confiurations originally passed
-- to this TermWindow instance wihtin Init
-- returns the window ID generated by nvim_open_win
---@param onLeave function
function TermWindow:Show(onLeave)
  self:RecreateBuf()
  if not self.config then
    error("TermWindow:Show(): Self.config is nil", 2)
  end
  local winid = api.nvim_open_win(self.bufnr, true, self.config)
  vim.wo[winid].winfixbuf = true -- Disables loading files in TermWindow

  self.winid  = winid
  self.onHide = onLeave
  self:SpawnShell(onLeave)
  self.showing = true;
  Keymaps.AddTermKeyMaps(self.bufnr)
  return winid
end

function TermWindow:Hide()
  if not self.winid or not api.nvim_win_is_valid(self.winid) then
    return
  end

  Keymaps.RemoveTermKeymaps(self.bufnr)

  self.showing = false;
  api.nvim_win_hide(self.winid)
  self.winid = nil
end

function TermWindow:Delete()
  self:Hide()
  self.bufnr = nil
  self.termid = nil
end

---@param config table
function TermWindow:UpdateConfig(config)
  self.config = config
end



return {
  TermWindow = TermWindow,
}
